"""empty message

Revision ID: 5aafeb2c295f
Revises: 01a7c27aad49
Create Date: 2024-05-22 13:06:07.204787

"""
from alembic import op
from sqlalchemy.schema import Sequence, CreateSequence, DropSequence
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '5aafeb2c295f'
down_revision = '01a7c27aad49'
branch_labels = None
depends_on = None


def upgrade(engine_name):
    globals()["upgrade_%s" % engine_name]()


def downgrade(engine_name):
    globals()["downgrade_%s" % engine_name]()





def upgrade_():
    op.execute(CreateSequence(Sequence('coordinator_request_id_seq')))

    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('interest_rate_change',
    sa.Column('creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('change_ts', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.Column('interest_rate', sa.REAL(), nullable=False),
    sa.CheckConstraint('interest_rate >= -100.0'),
    comment='Indicates a change in the interest rate on a given collector account. The history of recent interest rate changes is needed in order to correctly determine the due interest on traded amounts.'
    )
    # Create a "covering" index instead of a "normal" index.
    op.execute('CREATE UNIQUE INDEX idx_interest_rate_change_pk ON interest_rate_change (creditor_id, debtor_id, change_ts) INCLUDE (interest_rate)')
    op.execute('ALTER TABLE interest_rate_change ADD CONSTRAINT interest_rate_change_pkey PRIMARY KEY USING INDEX idx_interest_rate_change_pk')

    op.create_table('account_lock',
    sa.Column('creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('turn_id', sa.Integer(), nullable=False),
    sa.Column('collector_id', sa.BigInteger(), nullable=False),
    sa.Column('initiated_at', sa.TIMESTAMP(timezone=True), nullable=False, comment='The timestamp of the sent `PrepareTransfer` SMP message.'),
    sa.Column('coordinator_request_id', sa.BigInteger(), server_default=sa.text("nextval('coordinator_request_id_seq')"), nullable=False),
    sa.Column('amount', sa.BigInteger(), nullable=False, comment='Can be negative or zero (the trader wants to sell), or positive (the trader wants to buy). When selling, and the `transfer_id` column is being set to a non-NULL value, the amount will be re-calculated to be equal to the locked amount reduced in accordance with the effective demurrage rate. Also, when selling, and the `finalized_at` column is being set to a non-NULL value, the amount will be re-set to be equal to the committed amount with a negative sign.'),
    sa.Column('transfer_id', sa.BigInteger(), nullable=True),
    sa.Column('finalized_at', sa.TIMESTAMP(timezone=True), nullable=True, comment='The timestamp of the sent `FinalizeTransfer` SMP message.'),
    sa.Column('released_at', sa.TIMESTAMP(timezone=True), nullable=True),
    sa.Column('account_creation_date', sa.DATE(), nullable=True),
    sa.Column('account_last_transfer_number', sa.BigInteger(), nullable=True),
    sa.CheckConstraint('finalized_at IS NULL OR transfer_id IS NOT NULL'),
    sa.CheckConstraint('released_at IS NULL OR finalized_at IS NOT NULL AND account_creation_date IS NOT NULL AND account_last_transfer_number IS NOT NULL'),
    sa.ForeignKeyConstraint(['turn_id'], ['worker_turn.turn_id'], ),
    sa.PrimaryKeyConstraint('creditor_id', 'debtor_id'),
    comment='Represents an attempt to arrange the participation of a given account in a given trading turn. Normally, this includes sending a `PrepareTransfer` SMP message.'
    )
    with op.batch_alter_table('account_lock', schema=None) as batch_op:
        batch_op.create_index('idx_lock_account_coordinator_request_id', ['coordinator_request_id'], unique=True)
        batch_op.create_index('idx_lock_account_turn_id', ['turn_id'], unique=False)

    with op.batch_alter_table('prepare_transfer_signal', schema=None) as batch_op:
        batch_op.add_column(sa.Column('min_locked_amount', sa.BigInteger(), nullable=False))
        batch_op.add_column(sa.Column('max_locked_amount', sa.BigInteger(), nullable=False))
        batch_op.add_column(sa.Column('final_interest_rate_ts', sa.TIMESTAMP(timezone=True), nullable=False))
        batch_op.drop_column('min_interest_rate')
        batch_op.drop_column('locked_amount')

    # ### end Alembic commands ###


def downgrade_():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('prepare_transfer_signal', schema=None) as batch_op:
        batch_op.add_column(sa.Column('locked_amount', sa.BIGINT(), autoincrement=False, nullable=False))
        batch_op.add_column(sa.Column('min_interest_rate', sa.DOUBLE_PRECISION(precision=53), autoincrement=False, nullable=False))
        batch_op.drop_column('final_interest_rate_ts')
        batch_op.drop_column('max_locked_amount')
        batch_op.drop_column('min_locked_amount')

    with op.batch_alter_table('account_lock', schema=None) as batch_op:
        batch_op.drop_index('idx_lock_account_turn_id')
        batch_op.drop_index('idx_lock_account_coordinator_request_id')

    op.drop_table('account_lock')
    op.drop_table('interest_rate_change')
    # ### end Alembic commands ###

    op.execute(DropSequence(Sequence('coordinator_request_id_seq')))


def upgrade_solver():
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###


def downgrade_solver():
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###

