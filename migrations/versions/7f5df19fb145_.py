"""empty message

Revision ID: 7f5df19fb145
Revises: 
Create Date: 2025-11-23 14:02:57.275587

"""
from alembic import op
from sqlalchemy.schema import Sequence, CreateSequence, DropSequence
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '7f5df19fb145'
down_revision = None
branch_labels = None
depends_on = None


def upgrade(engine_name):
    globals()["upgrade_%s" % engine_name]()


def downgrade(engine_name):
    globals()["downgrade_%s" % engine_name]()





def upgrade_():
    op.execute(CreateSequence(Sequence('coordinator_request_id_seq')))

    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('account_id_request_signal',
    sa.Column('signal_id', sa.BigInteger(), autoincrement=True, nullable=False),
    sa.Column('collector_id', sa.BigInteger(), nullable=False),
    sa.Column('turn_id', sa.Integer(), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('is_dispatching', sa.BOOLEAN(), nullable=False),
    sa.Column('inserted_at', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.PrimaryKeyConstraint('signal_id')
    )
    op.create_table('account_id_response_signal',
    sa.Column('signal_id', sa.BigInteger(), autoincrement=True, nullable=False),
    sa.Column('collector_id', sa.BigInteger(), nullable=False),
    sa.Column('turn_id', sa.Integer(), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('is_dispatching', sa.BOOLEAN(), nullable=False),
    sa.Column('account_id', sa.String(), nullable=False),
    sa.Column('account_id_version', sa.BigInteger(), nullable=False),
    sa.Column('inserted_at', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.PrimaryKeyConstraint('signal_id')
    )
    op.create_table('account_lock',
    sa.Column('creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('turn_id', sa.Integer(), nullable=False),
    sa.Column('collector_id', sa.BigInteger(), nullable=False),
    sa.Column('initiated_at', sa.TIMESTAMP(timezone=True), nullable=False, comment='The timestamp of the sent `PrepareTransfer` SMP message.'),
    sa.Column('coordinator_request_id', sa.BigInteger(), server_default=sa.text("nextval('coordinator_request_id_seq')"), nullable=False),
    sa.Column('amount', sa.BigInteger(), nullable=False, comment='Can be negative or zero (the trader wants to sell), or positive (the trader wants to buy). When selling, and the `transfer_id` column is being set to a non-NULL value, the amount will be re-calculated to be equal to the locked amount reduced in accordance with the effective demurrage rate. Also, when selling, and the `finalized_at` column is being set to a non-NULL value, the amount will be re-set to be equal to the committed amount with a negative sign.'),
    sa.Column('max_locked_amount', sa.BigInteger(), nullable=False, comment='An upper limit for the actual locked amount.'),
    sa.Column('transfer_id', sa.BigInteger(), nullable=True),
    sa.Column('finalized_at', sa.TIMESTAMP(timezone=True), nullable=True, comment='The timestamp of the sent `FinalizeTransfer` SMP message.'),
    sa.Column('released_at', sa.TIMESTAMP(timezone=True), nullable=True),
    sa.Column('account_creation_date', sa.DATE(), nullable=True),
    sa.Column('account_last_transfer_number', sa.BigInteger(), nullable=True),
    sa.Column('has_been_revised', sa.BOOLEAN(), nullable=False),
    sa.CheckConstraint('finalized_at IS NULL OR transfer_id IS NOT NULL'),
    sa.CheckConstraint('max_locked_amount >= 0'),
    sa.CheckConstraint('released_at IS NULL OR finalized_at IS NOT NULL AND account_creation_date IS NOT NULL AND account_last_transfer_number IS NOT NULL'),
    sa.PrimaryKeyConstraint('creditor_id', 'debtor_id'),
    comment='Represents an attempt to arrange the participation of a given account in a given trading turn. Normally, this includes sending a `PrepareTransfer` SMP message.'
    )
    with op.batch_alter_table('account_lock', schema=None) as batch_op:
        batch_op.create_index('idx_lock_account_coordinator_request_id', ['coordinator_request_id'], unique=True)
        batch_op.create_index('idx_lock_account_turn_id', ['turn_id'], unique=False)

    op.create_table('activate_collector_signal',
    sa.Column('signal_id', sa.BigInteger(), autoincrement=True, nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('account_id', sa.String(), nullable=False),
    sa.Column('creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('inserted_at', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.PrimaryKeyConstraint('signal_id')
    )
    op.create_table('candidate_offer_signal',
    sa.Column('turn_id', sa.SmallInteger(), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('amount', sa.BigInteger(), nullable=False),
    sa.Column('account_creation_date', sa.DATE(), nullable=False),
    sa.Column('last_transfer_number', sa.BigInteger(), nullable=False),
    sa.Column('inserted_at', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.PrimaryKeyConstraint('turn_id', 'debtor_id', 'creditor_id')
    )
    op.create_table('configure_account_signal',
    sa.Column('creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('ts', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.Column('seqnum', sa.Integer(), nullable=False),
    sa.Column('negligible_amount', sa.REAL(), nullable=False),
    sa.Column('config_data', sa.String(), nullable=False),
    sa.Column('config_flags', sa.Integer(), nullable=False),
    sa.Column('inserted_at', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.PrimaryKeyConstraint('creditor_id', 'debtor_id', 'ts', 'seqnum')
    )
    op.create_table('confirm_debtor_signal',
    sa.Column('signal_id', sa.BigInteger(), autoincrement=True, nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('debtor_info_locator', sa.String(), nullable=False),
    sa.Column('inserted_at', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.PrimaryKeyConstraint('signal_id')
    )
    op.create_table('creditor_participation',
    sa.Column('creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('turn_id', sa.Integer(), nullable=False),
    sa.Column('amount', sa.BigInteger(), nullable=False, comment='Can be positive or negative, but can not be zero or one. A positive number indicates that this amount should be given to the creditor. A negative number indicates that this amount should be taken from the creditor.'),
    sa.Column('collector_id', sa.BigInteger(), nullable=False),
    sa.CheckConstraint('amount < 0 OR amount > 1'),
    sa.PrimaryKeyConstraint('creditor_id', 'debtor_id', 'turn_id'),
    comment='Indicates that the given amount must be given or taken to/from the given creditor as part of the given trading turn. During the phase 3 of each turn, "worker" servers will move the records from the "creditor_giving" and and "creditor_taking" solver tables to this table.'
    )
    op.create_table('debtor_info_document',
    sa.Column('debtor_info_locator', sa.String(), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('peg_debtor_info_locator', sa.String(), nullable=True),
    sa.Column('peg_debtor_id', sa.BigInteger(), nullable=True),
    sa.Column('peg_exchange_rate', sa.FLOAT(), nullable=True),
    sa.Column('will_not_change_until', sa.TIMESTAMP(timezone=True), nullable=True),
    sa.Column('fetched_at', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.CheckConstraint('peg_debtor_info_locator IS NULL AND peg_debtor_id IS NULL AND peg_exchange_rate IS NULL OR peg_debtor_info_locator IS NOT NULL AND peg_debtor_id IS NOT NULL AND peg_exchange_rate IS NOT NULL'),
    sa.CheckConstraint('peg_exchange_rate >= 0.0'),
    sa.PrimaryKeyConstraint('debtor_info_locator'),
    comment="Represents relevant trading information about a given currency (aka debtor), that have been parsed from the debtor's debtor info document, obtained via HTTP request."
    )
    op.create_table('debtor_info_fetch',
    sa.Column('iri', sa.String(), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('is_locator_fetch', sa.BOOLEAN(), nullable=False),
    sa.Column('is_discovery_fetch', sa.BOOLEAN(), nullable=False),
    sa.Column('forced_iri', sa.String(), nullable=True),
    sa.Column('recursion_level', sa.SmallInteger(), nullable=False),
    sa.Column('inserted_at', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.Column('attempts_count', sa.SmallInteger(), nullable=False),
    sa.Column('latest_attempt_at', sa.TIMESTAMP(timezone=True), nullable=True),
    sa.Column('latest_attempt_errorcode', sa.SmallInteger(), nullable=True),
    sa.Column('next_attempt_at', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.CheckConstraint('attempts_count = 0 AND latest_attempt_at IS NULL AND latest_attempt_errorcode IS NULL OR attempts_count > 0 AND latest_attempt_at IS NOT NULL'),
    sa.CheckConstraint('recursion_level >= 0'),
    sa.PrimaryKeyConstraint('iri', 'debtor_id'),
    comment="Represents a scheduled HTTP request (HTTP fetch) to obtain relevant trading information about a given currency (aka debtor). There are two non-mutually exclusive request types: 1) a locator fetch, which wants to obtain the latest version of the debtor's debtor info document, from the official debtor info locator; 2) a discovery fetch, which wants to obtain a particular (possibly obsolete) version of the debtor's debtor info document, not necessarily from the official debtor info locator."
    )
    with op.batch_alter_table('debtor_info_fetch', schema=None) as batch_op:
        batch_op.create_index('idx_debtor_info_fetch_next_attempt_at', ['next_attempt_at'], unique=False)

    op.create_table('debtor_locator_claim',
    sa.Column('debtor_id', sa.BigInteger(), autoincrement=False, nullable=False),
    sa.Column('debtor_info_locator', sa.String(), nullable=True),
    sa.Column('latest_locator_fetch_at', sa.TIMESTAMP(timezone=True), nullable=True),
    sa.Column('latest_discovery_fetch_at', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.Column('forced_locator_refetch_at', sa.TIMESTAMP(timezone=True), nullable=True),
    sa.CheckConstraint('debtor_info_locator IS NULL AND latest_locator_fetch_at IS NULL OR debtor_info_locator IS NOT NULL AND latest_locator_fetch_at IS NOT NULL'),
    sa.PrimaryKeyConstraint('debtor_id'),
    comment='Represents a reliable claim made by a given debtor, declaring what the official debtor info locator for the given debtor is.'
    )

    op.create_table('delayed_account_transfer',
    sa.Column('turn_id', sa.Integer(), nullable=False),
    sa.Column('message_id', sa.BigInteger(), autoincrement=True, nullable=False),
    sa.Column('creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('creation_date', sa.DATE(), nullable=False),
    sa.Column('transfer_number', sa.BigInteger(), nullable=False),
    sa.Column('coordinator_type', sa.String(length=30), nullable=False),
    sa.Column('committed_at', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.Column('acquired_amount', sa.BigInteger(), nullable=False),
    sa.Column('transfer_note_format', sa.TEXT(), nullable=False),
    sa.Column('transfer_note', sa.TEXT(), nullable=False),
    sa.Column('principal', sa.BigInteger(), nullable=False),
    sa.Column('previous_transfer_number', sa.BigInteger(), nullable=False),
    sa.Column('sender', sa.String(length=100), nullable=False),
    sa.Column('recipient', sa.String(length=100), nullable=False),
    sa.Column('ts', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.PrimaryKeyConstraint('turn_id', 'message_id'),
    comment='Represents an `AccountTransfer` SMP message which has been triggered by the actions of another worker, and has been received by this worker, before it is ready to process it. Such messages will be saved in this table, in order to be "replayed" once this worker is ready to process them.'
    )
    op.create_table('discover_debtor_signal',
    sa.Column('signal_id', sa.BigInteger(), autoincrement=True, nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('force_locator_refetch', sa.Boolean(), nullable=False),
    sa.Column('iri', sa.String(), nullable=False),
    sa.Column('inserted_at', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.PrimaryKeyConstraint('signal_id')
    )
    op.create_table('dispatching_status',
    sa.Column('collector_id', sa.BigInteger(), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('turn_id', sa.Integer(), nullable=False),
    sa.Column('inserted_at', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.Column('amount_to_collect', sa.BigInteger(), nullable=False, comment='The sum of all amounts from the corresponding records in the "worker_collecting" table, at the moment the "dispatching_status" record has been created.'),
    sa.Column('total_collected_amount', sa.BigInteger(), nullable=True, comment='A non-NULL value indicates that no more transfers for corresponding records in the "worker_collecting" table will be collected.'),
    sa.Column('amount_to_send', sa.BigInteger(), nullable=False, comment='The sum of all amounts from the corresponding records in the "worker_sending" table, at the moment the "dispatching_status" record has been created.'),
    sa.Column('started_sending', sa.BOOLEAN(), nullable=False),
    sa.Column('all_sent', sa.BOOLEAN(), nullable=False),
    sa.Column('amount_to_receive', sa.BigInteger(), nullable=False, comment='The sum of all expected amounts from the corresponding records in the "worker_receiving" table, at the moment the "dispatching_status" record has been created.'),
    sa.Column('number_to_receive', sa.Integer(), nullable=False, comment='The number of corresponding records in the "worker_receiving" table, at the moment the "dispatching_status" record has been created.'),
    sa.Column('total_received_amount', sa.BigInteger(), nullable=True, comment='A non-NULL value indicates that no more transfers for corresponding records in the "worker_receiving" table will be received.'),
    sa.Column('all_received', sa.BOOLEAN(), nullable=False),
    sa.Column('amount_to_dispatch', sa.BigInteger(), nullable=False, comment='The sum of all amounts from the corresponding records in the "worker_dispatching" table, at the moment the "dispatching_status" record has been created.'),
    sa.Column('started_dispatching', sa.BOOLEAN(), nullable=False),
    sa.Column('awaiting_signal_flag', sa.BOOLEAN(), nullable=False),
    sa.CheckConstraint('all_received = false OR total_received_amount IS NOT NULL'),
    sa.CheckConstraint('all_sent = false OR started_sending = true'),
    sa.CheckConstraint('amount_to_collect >= 0'),
    sa.CheckConstraint('amount_to_dispatch >= 0'),
    sa.CheckConstraint('amount_to_receive >= 0'),
    sa.CheckConstraint('amount_to_send <= amount_to_collect'),
    sa.CheckConstraint('amount_to_send >= 0'),
    sa.CheckConstraint('number_to_receive >= 0'),
    sa.CheckConstraint('started_dispatching = (all_sent = true AND total_received_amount IS NOT NULL)'),
    sa.CheckConstraint('started_sending = (total_collected_amount IS NOT NULL)'),
    sa.CheckConstraint('total_collected_amount <= amount_to_collect'),
    sa.CheckConstraint('total_collected_amount >= 0'),
    sa.CheckConstraint('total_received_amount >= 0'),
    comment='Represents the status of the process of collecting, sending, receiving, and dispatching for a given collector account, during a given trading turn.'
    )
    # Create a "covering" index instead of a "normal" index.
    op.execute('CREATE UNIQUE INDEX idx_dispatching_status_pk ON dispatching_status (collector_id, debtor_id, turn_id) INCLUDE (started_sending, all_sent, started_dispatching, awaiting_signal_flag)')
    op.execute('ALTER TABLE dispatching_status ADD CONSTRAINT dispatching_status_pkey PRIMARY KEY USING INDEX idx_dispatching_status_pk')

    op.create_table('fetch_debtor_info_signal',
    sa.Column('signal_id', sa.BigInteger(), autoincrement=True, nullable=False),
    sa.Column('iri', sa.String(), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('is_locator_fetch', sa.BOOLEAN(), nullable=False),
    sa.Column('is_discovery_fetch', sa.BOOLEAN(), nullable=False),
    sa.Column('forced_iri', sa.String(), nullable=True),
    sa.Column('recursion_level', sa.SmallInteger(), nullable=False),
    sa.Column('inserted_at', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.PrimaryKeyConstraint('signal_id')
    )
    op.create_table('finalize_transfer_signal',
    sa.Column('creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('signal_id', sa.BigInteger(), autoincrement=True, nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('transfer_id', sa.BigInteger(), nullable=False),
    sa.Column('coordinator_id', sa.BigInteger(), nullable=False),
    sa.Column('coordinator_request_id', sa.BigInteger(), nullable=False),
    sa.Column('committed_amount', sa.BigInteger(), nullable=False),
    sa.Column('transfer_note_format', sa.String(), nullable=False),
    sa.Column('transfer_note', sa.String(), nullable=False),
    sa.Column('inserted_at', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.PrimaryKeyConstraint('creditor_id', 'signal_id')
    )
    op.create_table('interest_rate_change',
    sa.Column('creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('change_ts', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.Column('interest_rate', sa.REAL(), nullable=False),
    sa.CheckConstraint('interest_rate >= -100.0'),
    sa.PrimaryKeyConstraint('creditor_id', 'debtor_id', 'change_ts'),
    comment='Indicates a change in the interest rate on a given collector account. The history of recent interest rate changes is needed in order to correctly determine the due interest on traded amounts.'
    )
    op.create_table('needed_collector_signal',
    sa.Column('signal_id', sa.BigInteger(), autoincrement=True, nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('inserted_at', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.PrimaryKeyConstraint('signal_id')
    )
    op.create_table('needed_worker_account',
    sa.Column('creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('configured_at', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.Column('collection_disabled_since', sa.TIMESTAMP(timezone=True), nullable=True),
    sa.Column('blocked_amount', sa.BigInteger(), nullable=True),
    sa.Column('blocked_amount_ts', sa.TIMESTAMP(timezone=True), nullable=True),
    sa.CheckConstraint('blocked_amount >= 0'),
    sa.PrimaryKeyConstraint('creditor_id', 'debtor_id'),
    comment='Represents the fact that a "worker" server has requested the configuration (aka creation) of a Swaptacular account, which will be used to collect and dispatch transfers.'
    )
    op.create_table('prepare_transfer_signal',
    sa.Column('creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('coordinator_request_id', sa.BigInteger(), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('recipient', sa.String(), nullable=False),
    sa.Column('min_locked_amount', sa.BigInteger(), nullable=False),
    sa.Column('max_locked_amount', sa.BigInteger(), nullable=False),
    sa.Column('final_interest_rate_ts', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.Column('max_commit_delay', sa.Integer(), nullable=False),
    sa.Column('inserted_at', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.PrimaryKeyConstraint('creditor_id', 'coordinator_request_id')
    )
    op.create_table('recently_needed_collector',
    sa.Column('debtor_id', sa.BigInteger(), autoincrement=False, nullable=False),
    sa.Column('needed_at', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.CheckConstraint('debtor_id != 0'),
    sa.PrimaryKeyConstraint('debtor_id'),
    comment='Indicates that the creation of a collector account for the currency with the given debtor ID has been recently requested. This information is used to prevent "worker" servers from making repetitive queries to the central database.'
    )
    op.create_table('replayed_account_transfer_signal',
    sa.Column('signal_id', sa.BigInteger(), autoincrement=True, nullable=False),
    sa.Column('creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('creation_date', sa.DATE(), nullable=False),
    sa.Column('transfer_number', sa.BigInteger(), nullable=False),
    sa.Column('coordinator_type', sa.String(length=30), nullable=False),
    sa.Column('committed_at', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.Column('acquired_amount', sa.BigInteger(), nullable=False),
    sa.Column('transfer_note_format', sa.TEXT(), nullable=False),
    sa.Column('transfer_note', sa.TEXT(), nullable=False),
    sa.Column('principal', sa.BigInteger(), nullable=False),
    sa.Column('previous_transfer_number', sa.BigInteger(), nullable=False),
    sa.Column('sender', sa.String(length=100), nullable=False),
    sa.Column('recipient', sa.String(length=100), nullable=False),
    sa.Column('ts', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.Column('inserted_at', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.PrimaryKeyConstraint('signal_id')
    )
    op.create_table('revise_account_lock_signal',
    sa.Column('signal_id', sa.BigInteger(), autoincrement=True, nullable=False),
    sa.Column('creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('turn_id', sa.Integer(), nullable=False),
    sa.Column('inserted_at', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.PrimaryKeyConstraint('signal_id')
    )
    op.create_table('start_dispatching_signal',
    sa.Column('signal_id', sa.BigInteger(), autoincrement=True, nullable=False),
    sa.Column('collector_id', sa.BigInteger(), nullable=False),
    sa.Column('turn_id', sa.Integer(), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('inserted_at', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.PrimaryKeyConstraint('signal_id')
    )
    op.create_table('start_sending_signal',
    sa.Column('signal_id', sa.BigInteger(), autoincrement=True, nullable=False),
    sa.Column('collector_id', sa.BigInteger(), nullable=False),
    sa.Column('turn_id', sa.Integer(), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('inserted_at', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.PrimaryKeyConstraint('signal_id')
    )
    op.create_table('store_document_signal',
    sa.Column('signal_id', sa.BigInteger(), autoincrement=True, nullable=False),
    sa.Column('debtor_info_locator', sa.String(), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('peg_debtor_info_locator', sa.String(), nullable=True),
    sa.Column('peg_debtor_id', sa.BigInteger(), nullable=True),
    sa.Column('peg_exchange_rate', sa.FLOAT(), nullable=True),
    sa.Column('will_not_change_until', sa.TIMESTAMP(timezone=True), nullable=True),
    sa.Column('inserted_at', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.PrimaryKeyConstraint('signal_id')
    )
    op.create_table('trading_policy',
    sa.Column('creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('latest_ledger_update_id', sa.BigInteger(), nullable=False),
    sa.Column('latest_ledger_update_ts', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.Column('account_id', sa.String(), nullable=False),
    sa.Column('account_id_is_obsolete', sa.BOOLEAN(), nullable=False),
    sa.Column('creation_date', sa.DATE(), nullable=False),
    sa.Column('principal', sa.BigInteger(), nullable=False),
    sa.Column('last_transfer_number', sa.BigInteger(), nullable=False),
    sa.Column('latest_policy_update_id', sa.BigInteger(), nullable=False),
    sa.Column('latest_policy_update_ts', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.Column('policy_name', sa.String(), nullable=True),
    sa.Column('min_principal', sa.BigInteger(), nullable=False),
    sa.Column('max_principal', sa.BigInteger(), nullable=False),
    sa.Column('peg_debtor_id', sa.BigInteger(), nullable=True),
    sa.Column('peg_exchange_rate', sa.FLOAT(), nullable=True),
    sa.Column('latest_flags_update_id', sa.BigInteger(), nullable=False),
    sa.Column('latest_flags_update_ts', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.Column('config_flags', sa.Integer(), nullable=False),
    sa.CheckConstraint('last_transfer_number >= 0'),
    sa.CheckConstraint('latest_flags_update_id >= 0'),
    sa.CheckConstraint('latest_ledger_update_id >= 0'),
    sa.CheckConstraint('latest_policy_update_id >= 0'),
    sa.CheckConstraint('peg_debtor_id IS NULL AND peg_exchange_rate IS NULL OR peg_debtor_id IS NOT NULL AND peg_exchange_rate IS NOT NULL'),
    sa.CheckConstraint('peg_exchange_rate >= 0.0'),
    sa.PrimaryKeyConstraint('creditor_id', 'debtor_id'),
    comment="Represents important information about a given customer account. This includes things like: the account's ID, the available amount, the customer's trading policy etc."
    )
    op.create_table('transfer_attempt',
    sa.Column('collector_id', sa.BigInteger(), nullable=False, comment='This is the creditor ID of the sender.'),
    sa.Column('turn_id', sa.Integer(), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('creditor_id', sa.BigInteger(), nullable=False, comment='This is the creditor ID of the recipient.'),
    sa.Column('is_dispatching', sa.BOOLEAN(), nullable=False, comment='Will be TRUE when the collector is dispatching some amount to a buyer, and FALSE when the collector is sending some amount to another collector.'),
    sa.Column('nominal_amount', sa.FLOAT(), nullable=False),
    sa.Column('collection_started_at', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.Column('inserted_at', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.Column('recipient', sa.String(), nullable=False),
    sa.Column('recipient_version', sa.BigInteger(), nullable=False, comment='In very rare cases the recipient may be change. This column allows us to tell which recipient value is newer.'),
    sa.Column('rescheduled_for', sa.TIMESTAMP(timezone=True), nullable=True),
    sa.Column('attempted_at', sa.TIMESTAMP(timezone=True), nullable=True, comment='The timestamp of the sent `PrepareTransfer` SMP message.'),
    sa.Column('coordinator_request_id', sa.BigInteger(), nullable=True),
    sa.Column('final_interest_rate_ts', sa.TIMESTAMP(timezone=True), nullable=True),
    sa.Column('amount', sa.BigInteger(), nullable=True),
    sa.Column('transfer_id', sa.BigInteger(), nullable=True),
    sa.Column('finalized_at', sa.TIMESTAMP(timezone=True), nullable=True, comment='The timestamp of the sent `FinalizeTransfer` SMP message.'),
    sa.Column('failure_code', sa.SmallInteger(), nullable=True, comment='Failure codes: 0) An unspecified failure; 1) TIMEOUT; 2) NEWER_INTEREST_RATE; 3) RECIPIENT_IS_UNREACHABLE; 4) INSUFFICIENT_AVAILABLE_AMOUNT.'),
    sa.Column('backoff_counter', sa.SmallInteger(), nullable=False),
    sa.Column('fatal_error', sa.String(), nullable=True),
    sa.CheckConstraint("attempted_at IS NULL AND coordinator_request_id IS NULL AND final_interest_rate_ts IS NULL AND amount IS NULL OR attempted_at IS NOT NULL AND coordinator_request_id IS NOT NULL AND final_interest_rate_ts IS NOT NULL AND amount IS NOT NULL AND recipient != ''"),
    sa.CheckConstraint('amount > 0'),
    sa.CheckConstraint('backoff_counter >= 0'),
    sa.CheckConstraint('failure_code IS NULL OR attempted_at IS NOT NULL'),
    sa.CheckConstraint('fatal_error IS NULL OR failure_code = 0 AND rescheduled_for IS NULL'),
    sa.CheckConstraint('nominal_amount >= 1.0'),
    sa.CheckConstraint('rescheduled_for IS NULL OR attempted_at IS NULL OR failure_code IS NOT NULL'),
    sa.CheckConstraint('transfer_id IS NULL AND finalized_at IS NULL OR transfer_id IS NOT NULL AND finalized_at IS NOT NULL'),
    sa.CheckConstraint('transfer_id IS NULL OR attempted_at IS NOT NULL'),
    sa.PrimaryKeyConstraint('collector_id', 'turn_id', 'debtor_id', 'creditor_id', 'is_dispatching'),
    comment="Represents a past or future attempt to transfer some amount form a given collector's account to another account, as a part of a given trading turn. More than one attempt may be made if the first attempt has failed."
    )
    with op.batch_alter_table('transfer_attempt', schema=None) as batch_op:
        batch_op.create_index('idx_transfer_coordinator_request_id', ['coordinator_request_id'], unique=True, postgresql_where=sa.text('coordinator_request_id IS NOT NULL'))
        batch_op.create_index('idx_transfer_rescheduled_for', ['rescheduled_for'], unique=False, postgresql_where=sa.text('rescheduled_for IS NOT NULL'))

    op.create_table('trigger_transfer_signal',
    sa.Column('signal_id', sa.BigInteger(), autoincrement=True, nullable=False),
    sa.Column('collector_id', sa.BigInteger(), nullable=False),
    sa.Column('turn_id', sa.Integer(), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('is_dispatching', sa.BOOLEAN(), nullable=False),
    sa.Column('inserted_at', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.PrimaryKeyConstraint('signal_id')
    )
    op.create_table('usable_collector',
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('collector_id', sa.BigInteger(), nullable=False),
    sa.Column('account_id', sa.String(), nullable=False),
    sa.Column('disabled_at', sa.TIMESTAMP(timezone=True), nullable=True),
    sa.CheckConstraint("account_id != ''"),
    sa.PrimaryKeyConstraint('debtor_id', 'collector_id'),
    comment='Represents an existing Swaptacular account which can be used to collect and dispatch transfers. Each "Worker" servers will maintain its own copy of this table (that is: no rows-sharding) by periodically copying the relevant records from the solver\'s "collector_account" table. "Worker" servers will use this local copy so as to avoid querying the central database too often.'
    )
    with op.batch_alter_table('usable_collector', schema=None) as batch_op:
        batch_op.create_index('idx_usable_collector_collector_id', ['collector_id', 'debtor_id'], unique=True)

    op.create_table('worker_account',
    sa.Column('creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('creation_date', sa.DATE(), nullable=False),
    sa.Column('last_change_ts', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.Column('last_change_seqnum', sa.Integer(), nullable=False),
    sa.Column('principal', sa.BigInteger(), nullable=False),
    sa.Column('interest', sa.FLOAT(), nullable=False),
    sa.Column('interest_rate', sa.REAL(), nullable=False),
    sa.Column('last_interest_rate_change_ts', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.Column('config_flags', sa.Integer(), nullable=False),
    sa.Column('account_id', sa.String(), nullable=False),
    sa.Column('debtor_info_iri', sa.String(), nullable=True),
    sa.Column('last_transfer_number', sa.BigInteger(), nullable=False),
    sa.Column('last_transfer_committed_at', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.Column('demurrage_rate', sa.FLOAT(), nullable=False),
    sa.Column('commit_period', sa.Integer(), nullable=False),
    sa.Column('transfer_note_max_bytes', sa.Integer(), nullable=False),
    sa.Column('last_heartbeat_ts', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.Column('surplus_amount', sa.BigInteger(), nullable=False, comment='The calculated surplus on this account. The surplus can be spent on behalf of the owner of the creditors agent node.'),
    sa.Column('surplus_ts', sa.TIMESTAMP(timezone=True), nullable=False, comment='The moment when the surplus was observed. This is needed so that, for the current moment, we can calculate the maximum possible demurrage that surplus may have suffered.'),
    sa.Column('surplus_spent_amount', sa.BigInteger(), nullable=False, comment='The surplus amount which already has been spent on behalf of the owner of the creditors agent node.'),
    sa.Column('surplus_last_transfer_number', sa.BigInteger(), nullable=False, comment='This number must be incremented each time when `surplus_ts` change, or a trade has been made on behalf of the owner of the creditors agent node. This is necessary in order to avoid double-spending and double-buying.'),
    sa.CheckConstraint('commit_period >= 0'),
    sa.CheckConstraint('demurrage_rate >= -100.0 AND demurrage_rate <= 0.0'),
    sa.CheckConstraint('interest_rate >= -100.0'),
    sa.CheckConstraint('last_transfer_number >= 0'),
    sa.CheckConstraint('surplus_amount >= 0'),
    sa.CheckConstraint('surplus_last_transfer_number >= 0'),
    sa.CheckConstraint('surplus_spent_amount >= 0'),
    sa.CheckConstraint('transfer_note_max_bytes >= 0'),
    sa.PrimaryKeyConstraint('creditor_id', 'debtor_id'),
    comment='Represents an existing Swaptacular account, managed by a  "worker" server. The account is used to collect and dispatch transfers.'
    )
    op.create_table('worker_collecting',
    sa.Column('collector_id', sa.BigInteger(), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('turn_id', sa.Integer(), nullable=False),
    sa.Column('creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('amount', sa.BigInteger(), nullable=False),
    sa.Column('collected', sa.BOOLEAN(), nullable=False),
    sa.Column('purge_after', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.CheckConstraint('amount > 0'),
    sa.CheckConstraint('collector_id != creditor_id'),
    comment='Indicates that the given amount will be withdrawn (collected) from the given creditor\'s account, as part of the given trading turn, and will be transferred to the given collector. During the phase 3 of each turn, "worker" servers will move the records from the "collector_collecting" solver table to this table.'
    )
    # Create a "covering" index instead of a "normal" index.
    op.execute('CREATE UNIQUE INDEX idx_worker_collecting_pk ON worker_collecting (collector_id, debtor_id, turn_id, creditor_id) INCLUDE (amount)')
    op.execute('ALTER TABLE worker_collecting ADD CONSTRAINT worker_collecting_pkey PRIMARY KEY USING INDEX idx_worker_collecting_pk')

    with op.batch_alter_table('worker_collecting', schema=None) as batch_op:
        batch_op.create_index('idx_worker_collecting_not_collected', ['collector_id', 'debtor_id', 'turn_id', 'creditor_id'], unique=False, postgresql_where=sa.text('collected = false'))

    op.create_table('worker_dispatching',
    sa.Column('collector_id', sa.BigInteger(), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('turn_id', sa.Integer(), nullable=False),
    sa.Column('creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('amount', sa.BigInteger(), nullable=False),
    sa.Column('purge_after', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.CheckConstraint('amount > 1'),
    sa.CheckConstraint('collector_id != creditor_id'),
    comment='Indicates that the given amount must be deposited (dispatched) to the given customer account, as part of the given trading turn. During the phase 3 of each turn, "worker" servers will move the records from the "collector_dispatching" solver table to this table.'
    )
    # Create a "covering" index instead of a "normal" index.
    op.execute('CREATE UNIQUE INDEX idx_worker_dispatching_pk ON worker_dispatching (collector_id, debtor_id, turn_id, creditor_id) INCLUDE (amount)')
    op.execute('ALTER TABLE worker_dispatching ADD CONSTRAINT worker_dispatching_pkey PRIMARY KEY USING INDEX idx_worker_dispatching_pk')

    op.create_table('worker_receiving',
    sa.Column('to_collector_id', sa.BigInteger(), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('turn_id', sa.Integer(), nullable=False),
    sa.Column('from_collector_id', sa.BigInteger(), nullable=False),
    sa.Column('expected_amount', sa.BigInteger(), nullable=False),
    sa.Column('received_amount', sa.BigInteger(), nullable=False, comment='The received amount will be equal to the expected amount minus the accumulated negative interest (that is: when the interest rate is negative).'),
    sa.Column('purge_after', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.CheckConstraint('expected_amount > 1'),
    sa.CheckConstraint('from_collector_id != to_collector_id'),
    sa.CheckConstraint('received_amount >= 0'),
    comment='Indicates that some amount will be transferred (received) from another collector account, as part of the given trading turn. During the phase 3 of each turn, "worker" servers will move the records from the "collector_receiving" solver table to this table.'
    )
    # Create a "covering" index instead of a "normal" index.
    op.execute('CREATE UNIQUE INDEX idx_worker_receiving_pk ON worker_receiving (to_collector_id, debtor_id, turn_id, from_collector_id) INCLUDE (received_amount)')
    op.execute('ALTER TABLE worker_receiving ADD CONSTRAINT worker_receiving_pkey PRIMARY KEY USING INDEX idx_worker_receiving_pk')

    with op.batch_alter_table('worker_receiving', schema=None) as batch_op:
        batch_op.create_index('idx_worker_receiving_not_received', ['to_collector_id', 'debtor_id', 'turn_id', 'from_collector_id'], unique=False, postgresql_where=sa.text('received_amount = 0'))

    op.create_table('worker_sending',
    sa.Column('from_collector_id', sa.BigInteger(), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('turn_id', sa.Integer(), nullable=False),
    sa.Column('to_collector_id', sa.BigInteger(), nullable=False),
    sa.Column('amount', sa.BigInteger(), nullable=False),
    sa.Column('purge_after', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.CheckConstraint('amount > 1'),
    sa.CheckConstraint('from_collector_id != to_collector_id'),
    comment='Indicates that the given amount must be transferred (sent) to another collector account, as part of the given trading turn. During the phase 3 of each turn, "worker" servers will move the records from the "collector_sending" solver table to this table.'
    )
    # Create a "covering" index instead of a "normal" index.
    op.execute('CREATE UNIQUE INDEX idx_worker_sending_pk ON worker_sending (from_collector_id, debtor_id, turn_id, to_collector_id) INCLUDE (amount)')
    op.execute('ALTER TABLE worker_sending ADD CONSTRAINT worker_sending_pkey PRIMARY KEY USING INDEX idx_worker_sending_pk')

    op.create_table('worker_turn',
    sa.Column('turn_id', sa.Integer(), autoincrement=False, nullable=False),
    sa.Column('started_at', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.Column('base_debtor_info_locator', sa.String(), nullable=False),
    sa.Column('base_debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('max_distance_to_base', sa.SmallInteger(), nullable=False),
    sa.Column('min_trade_amount', sa.BigInteger(), nullable=False),
    sa.Column('phase', sa.SmallInteger(), nullable=False),
    sa.Column('phase_deadline', sa.TIMESTAMP(timezone=True), nullable=True),
    sa.Column('collection_started_at', sa.TIMESTAMP(timezone=True), nullable=True),
    sa.Column('collection_deadline', sa.TIMESTAMP(timezone=True), nullable=True),
    sa.Column('worker_turn_subphase', sa.SmallInteger(), nullable=False, comment='The worker may divide the processing of each phase to one or more sub-phases. The initial sub-phase is always `0`, and the final sub-phase is always `10`. Sequential sub-phases do not need to be (and normally will not be) represented by sequential numbers. This gives the freedom to add sub-phases if necessary.'),
    sa.CheckConstraint('base_debtor_id != 0'),
    sa.CheckConstraint('max_distance_to_base > 0'),
    sa.CheckConstraint('min_trade_amount > 0'),
    sa.CheckConstraint('phase < 2 OR collection_deadline IS NOT NULL'),
    sa.CheckConstraint('phase < 3 OR collection_started_at IS NOT NULL'),
    sa.CheckConstraint('phase > 0 AND phase <= 3'),
    sa.CheckConstraint('phase > 2 OR phase_deadline IS NOT NULL'),
    sa.CheckConstraint('worker_turn_subphase >= 0 AND worker_turn_subphase <= 10'),
    sa.PrimaryKeyConstraint('turn_id'),
    comment='Represents a circular trading round in which a "worker" server participates. "Worker" servers will watch for new and changed rows in the solver\'s `turn` table, and will copy them off.'
    )
    with op.batch_alter_table('worker_turn', schema=None) as batch_op:
        batch_op.create_index('idx_worker_turn_phase', ['phase'], unique=False, postgresql_where=sa.text('phase < 3'))
        batch_op.create_index('idx_worker_turn_subphase', ['worker_turn_subphase'], unique=False, postgresql_where=sa.text('worker_turn_subphase < 10'))

    # ### end Alembic commands ###


def downgrade_():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('worker_turn', schema=None) as batch_op:
        batch_op.drop_index('idx_worker_turn_subphase', postgresql_where=sa.text('worker_turn_subphase < 10'))
        batch_op.drop_index('idx_worker_turn_phase', postgresql_where=sa.text('phase < 3'))

    op.drop_table('worker_turn')
    op.drop_table('worker_sending')
    with op.batch_alter_table('worker_receiving', schema=None) as batch_op:
        batch_op.drop_index('idx_worker_receiving_not_received', postgresql_where=sa.text('received_amount = 0'))

    op.drop_table('worker_receiving')
    op.drop_table('worker_dispatching')
    with op.batch_alter_table('worker_collecting', schema=None) as batch_op:
        batch_op.drop_index('idx_worker_collecting_not_collected', postgresql_where=sa.text('collected = false'))

    op.drop_table('worker_collecting')
    op.drop_table('worker_account')
    with op.batch_alter_table('usable_collector', schema=None) as batch_op:
        batch_op.drop_index('idx_usable_collector_collector_id')

    op.drop_table('usable_collector')
    op.drop_table('trigger_transfer_signal')
    with op.batch_alter_table('transfer_attempt', schema=None) as batch_op:
        batch_op.drop_index('idx_transfer_rescheduled_for', postgresql_where=sa.text('rescheduled_for IS NOT NULL'))
        batch_op.drop_index('idx_transfer_coordinator_request_id', postgresql_where=sa.text('coordinator_request_id IS NOT NULL'))

    op.drop_table('transfer_attempt')
    op.drop_table('trading_policy')
    op.drop_table('store_document_signal')
    op.drop_table('start_sending_signal')
    op.drop_table('start_dispatching_signal')
    op.drop_table('revise_account_lock_signal')
    op.drop_table('replayed_account_transfer_signal')
    op.drop_table('recently_needed_collector')
    op.drop_table('prepare_transfer_signal')
    op.drop_table('needed_worker_account')
    op.drop_table('needed_collector_signal')
    op.drop_table('interest_rate_change')
    op.drop_table('finalize_transfer_signal')
    op.drop_table('fetch_debtor_info_signal')
    op.drop_table('dispatching_status')
    op.drop_table('discover_debtor_signal')
    op.drop_table('delayed_account_transfer')
    op.drop_table('debtor_locator_claim')
    with op.batch_alter_table('debtor_info_fetch', schema=None) as batch_op:
        batch_op.drop_index('idx_debtor_info_fetch_next_attempt_at')

    op.drop_table('debtor_info_fetch')
    op.drop_table('debtor_info_document')
    op.drop_table('creditor_participation')
    op.drop_table('confirm_debtor_signal')
    op.drop_table('configure_account_signal')
    op.drop_table('candidate_offer_signal')
    op.drop_table('activate_collector_signal')
    with op.batch_alter_table('account_lock', schema=None) as batch_op:
        batch_op.drop_index('idx_lock_account_turn_id')
        batch_op.drop_index('idx_lock_account_coordinator_request_id')

    op.drop_table('account_lock')
    op.drop_table('account_id_response_signal')
    op.drop_table('account_id_request_signal')
    # ### end Alembic commands ###

    op.execute(DropSequence(Sequence('coordinator_request_id_seq')))


def upgrade_solver():
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('buy_offer',
    sa.Column('turn_id', sa.Integer(), nullable=False),
    sa.Column('creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('amount', sa.BigInteger(), nullable=False),
    sa.CheckConstraint('amount > 0'),
    sa.PrimaryKeyConstraint('turn_id', 'creditor_id', 'debtor_id'),
    comment='Represents a buy offer, participating in a given trading turn. "Worker" servers are responsible for populating this table during the phase 2 of each turn. The "solver" server will read from this table, and will delete the records before advancing to phase 3 of the turn.'
    )
    op.create_table('collector_account',
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('collector_id', sa.BigInteger(), nullable=False),
    sa.Column('collector_hash', sa.SmallInteger(), nullable=False),
    sa.Column('account_id', sa.String(), nullable=False),
    sa.Column('status', sa.SmallInteger(), nullable=False, comment="Collector account's status: 0) pristine; 1) account creation has been requested; 2) the account has been created, and an account ID has been assigned to it; 3) disabled."),
    sa.Column('latest_status_change_at', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.CheckConstraint('status >= 0 AND status <= 3'),
    comment='Represents a planned or existing Swaptacular account, which should be used to collect and dispatch transfers. "Worker" servers will watch for new (pristine) records inserted in this table, and will try to create and use all the accounts catalogued in this table.'
    )
    # Create a "covering" index instead of a "normal" index.
    op.execute('CREATE UNIQUE INDEX idx_collector_account_pk ON collector_account (debtor_id, collector_id) INCLUDE (status)')
    op.execute('ALTER TABLE collector_account ADD CONSTRAINT collector_account_pkey PRIMARY KEY USING INDEX idx_collector_account_pk')

    with op.batch_alter_table('collector_account', schema=None) as batch_op:
        batch_op.create_index('idx_collector_account_creation_request', ['status'], unique=False, postgresql_where=sa.text('status = 0'))

    op.create_table('collector_collecting',
    sa.Column('turn_id', sa.Integer(), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('amount', sa.BigInteger(), nullable=False),
    sa.Column('collector_id', sa.BigInteger(), nullable=False),
    sa.Column('collector_hash', sa.SmallInteger(), nullable=False),
    sa.CheckConstraint('amount > 0'),
    sa.PrimaryKeyConstraint('turn_id', 'debtor_id', 'creditor_id'),
    comment='Informs the "worker" server responsible for the given collector, that the given amount will be withdrawn (collected) from the given customer account, as part of the given trading turn. During the phase 3 of each turn, "Worker" servers should make their own copy of the records in this table, and then delete the original records.'
    )
    op.create_table('collector_dispatching',
    sa.Column('turn_id', sa.Integer(), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('amount', sa.BigInteger(), nullable=False),
    sa.Column('collector_id', sa.BigInteger(), nullable=False),
    sa.Column('collector_hash', sa.SmallInteger(), nullable=False),
    sa.CheckConstraint('amount > 0'),
    sa.PrimaryKeyConstraint('turn_id', 'debtor_id', 'creditor_id'),
    comment='Informs the "worker" server responsible for the given collector, that the given amount must be deposited (dispatched) to the given customer account, as part of the given trading turn. During the phase 3 of each turn, "Worker" servers should make their own copy of the records in this table, and then delete the original records.'
    )
    op.create_table('collector_receiving',
    sa.Column('turn_id', sa.Integer(), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('to_collector_id', sa.BigInteger(), nullable=False),
    sa.Column('from_collector_id', sa.BigInteger(), nullable=False),
    sa.Column('to_collector_hash', sa.SmallInteger(), nullable=False),
    sa.Column('amount', sa.BigInteger(), nullable=False),
    sa.CheckConstraint('amount > 0'),
    sa.CheckConstraint('from_collector_id != to_collector_id'),
    sa.PrimaryKeyConstraint('turn_id', 'debtor_id', 'to_collector_id', 'from_collector_id'),
    comment='Informs the "worker" server responsible for the given "to collector" account, that the given amount will be transferred (received) from another collector account, as part of the given trading turn. During the phase 3 of each turn, "Worker" servers should make their own copy of the records in this table, and then delete the original records.'
    )
    op.create_table('collector_sending',
    sa.Column('turn_id', sa.Integer(), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('from_collector_id', sa.BigInteger(), nullable=False),
    sa.Column('to_collector_id', sa.BigInteger(), nullable=False),
    sa.Column('from_collector_hash', sa.SmallInteger(), nullable=False),
    sa.Column('amount', sa.BigInteger(), nullable=False),
    sa.CheckConstraint('amount > 0'),
    sa.CheckConstraint('from_collector_id != to_collector_id'),
    sa.PrimaryKeyConstraint('turn_id', 'debtor_id', 'from_collector_id', 'to_collector_id'),
    comment='Informs the "worker" server responsible for the given "from collector" account, that the given amount must be transferred (sent) to another collector account, as part of the given trading turn. During the phase 3 of each turn, "Worker" servers should make their own copy of the records in this table, and then delete the original records.'
    )
    op.create_table('confirmed_debtor',
    sa.Column('turn_id', sa.Integer(), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('debtor_info_locator', sa.String(), nullable=False),
    sa.PrimaryKeyConstraint('turn_id', 'debtor_id'),
    comment='Represents the fact that a given currency (aka debtor) is verified (confirmed), so that this currency can be traded during the given trading turn. "Worker" servers are responsible for populating this table during the phase 1 of each turn. The "solver" server will read from this table, and will delete the records before advancing to phase 2 of the turn.'
    )
    op.create_table('creditor_giving',
    sa.Column('turn_id', sa.Integer(), nullable=False),
    sa.Column('creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('creditor_hash', sa.SmallInteger(), nullable=False),
    sa.Column('amount', sa.BigInteger(), nullable=False),
    sa.Column('collector_id', sa.BigInteger(), nullable=False),
    sa.CheckConstraint('amount > 0'),
    sa.PrimaryKeyConstraint('turn_id', 'creditor_id', 'debtor_id'),
    comment='Informs the "worker" server responsible for the given customer account, that the given amount will be deposited (given) to this account, as part of the given trading turn. During the phase 3 of each turn, "Worker" servers should make their own copy of the records in this table, and then delete the original records.'
    )
    op.create_table('creditor_taking',
    sa.Column('turn_id', sa.Integer(), nullable=False),
    sa.Column('creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('creditor_hash', sa.SmallInteger(), nullable=False),
    sa.Column('amount', sa.BigInteger(), nullable=False),
    sa.Column('collector_id', sa.BigInteger(), nullable=False),
    sa.CheckConstraint('amount > 0'),
    sa.PrimaryKeyConstraint('turn_id', 'creditor_id', 'debtor_id'),
    comment='Informs the "worker" server responsible for the given customer account, that the given amount must be withdrawn (taken) from the account, as part of the given trading turn. During the phase 3 of each turn, "Worker" servers should make their own copy of the records in this table, and then delete the original records.'
    )
    op.create_table('currency_info',
    sa.Column('turn_id', sa.Integer(), nullable=False),
    sa.Column('debtor_info_locator', sa.String(), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('peg_debtor_info_locator', sa.String(), nullable=True),
    sa.Column('peg_debtor_id', sa.BigInteger(), nullable=True),
    sa.Column('peg_exchange_rate', sa.FLOAT(), nullable=True),
    sa.Column('is_confirmed', sa.BOOLEAN(), nullable=False),
    sa.PrimaryKeyConstraint('turn_id', 'debtor_info_locator'),
    comment='Represents relevant information about a given currency (aka debtor), so that the currency can participate in a given trading turn. The "solver" server will populate this table before the start of phase 2 of each turn, and will delete the records before advancing to phase 3. "Worker" servers will read from this table, so as to generate relevant buy and sell offers.'
    )
    with op.batch_alter_table('currency_info', schema=None) as batch_op:
        batch_op.create_index('idx_currency_info_confirmed_debtor_id', ['turn_id', 'debtor_id'], unique=True, postgresql_where=sa.text('is_confirmed'))

    op.create_table('debtor_info',
    sa.Column('turn_id', sa.Integer(), nullable=False),
    sa.Column('debtor_info_locator', sa.String(), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('peg_debtor_info_locator', sa.String(), nullable=True),
    sa.Column('peg_debtor_id', sa.BigInteger(), nullable=True),
    sa.Column('peg_exchange_rate', sa.FLOAT(), nullable=True),
    sa.PrimaryKeyConstraint('turn_id', 'debtor_info_locator'),
    comment='Represents relevant information about a given currency (aka debtor), so that the currency can participate in a given trading turn. "Worker" servers are responsible for populating this table during the phase 1 of each turn. The "solver" server will read from this table, and will delete the records before advancing to phase 2 of the turn.'
    )
    op.create_table('hoarded_currency',
    sa.Column('turn_id', sa.Integer(), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('peg_debtor_id', sa.BigInteger(), nullable=True),
    sa.Column('peg_exchange_rate', sa.FLOAT(), nullable=True),
    sa.CheckConstraint('peg_debtor_id IS NULL AND peg_exchange_rate IS NULL OR peg_debtor_id IS NOT NULL AND peg_exchange_rate IS NOT NULL'),
    sa.CheckConstraint('peg_exchange_rate >= 0.0'),
    sa.PrimaryKeyConstraint('turn_id', 'debtor_id'),
    comment='Represents the fact that during the given trading turn, the owner of the creditors agent node wants to buy (hoard) the given currency.'
    )
    op.create_table('overloaded_currency',
    sa.Column('turn_id', sa.Integer(), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('collectors_count', sa.Integer(), nullable=False),
    sa.CheckConstraint('collectors_count > 0'),
    sa.PrimaryKeyConstraint('turn_id', 'debtor_id'),
    comment='Represents the fact that during the given trading turn, the number of active collector accounts with the given currency have been too small to handle all the transfers.'
    )
    op.create_table('sell_offer',
    sa.Column('turn_id', sa.Integer(), nullable=False),
    sa.Column('creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('amount', sa.BigInteger(), nullable=False),
    sa.Column('collector_id', sa.BigInteger(), nullable=False),
    sa.CheckConstraint('amount > 0'),
    sa.PrimaryKeyConstraint('turn_id', 'creditor_id', 'debtor_id'),
    comment='Represents a sell offer, participating in a given trading turn. "Worker" servers are responsible for populating this table during the phase 2 of each turn. The "solver" server will read from this table, and will delete the records before advancing to phase 3 of the turn.'
    )
    op.create_table('turn',
    sa.Column('turn_id', sa.Integer(), autoincrement=True, nullable=False),
    sa.Column('started_at', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.Column('base_debtor_info_locator', sa.String(), nullable=False),
    sa.Column('base_debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('max_distance_to_base', sa.SmallInteger(), nullable=False),
    sa.Column('min_trade_amount', sa.BigInteger(), nullable=False),
    sa.Column('phase', sa.SmallInteger(), nullable=False, comment="Turn's phase: 1) gathering currencies info; 2) gathering buy and sell offers; 3) giving and taking; 4) done."),
    sa.Column('phase_deadline', sa.TIMESTAMP(timezone=True), nullable=True),
    sa.Column('collection_started_at', sa.TIMESTAMP(timezone=True), nullable=True),
    sa.Column('collection_deadline', sa.TIMESTAMP(timezone=True), nullable=True),
    sa.CheckConstraint('base_debtor_id != 0'),
    sa.CheckConstraint('max_distance_to_base > 0'),
    sa.CheckConstraint('min_trade_amount > 0'),
    sa.CheckConstraint('phase < 2 OR collection_deadline IS NOT NULL'),
    sa.CheckConstraint('phase < 3 OR collection_started_at IS NOT NULL'),
    sa.CheckConstraint('phase > 0 AND phase <= 4'),
    sa.CheckConstraint('phase > 2 OR phase_deadline IS NOT NULL'),
    sa.PrimaryKeyConstraint('turn_id'),
    comment='Represents a circular trading round, created and managed by the "solver" server. "Worker" servers will watch for changes in this table, so as to participate in the different phases of each trading round.'
    )
    with op.batch_alter_table('turn', schema=None) as batch_op:
        batch_op.create_index('idx_turn_phase', ['phase'], unique=False, postgresql_where=sa.text('phase < 4'))
        batch_op.create_index('idx_turn_started_at', ['started_at'], unique=False)

    # ### end Alembic commands ###


def downgrade_solver():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('turn', schema=None) as batch_op:
        batch_op.drop_index('idx_turn_started_at')
        batch_op.drop_index('idx_turn_phase', postgresql_where=sa.text('phase < 4'))

    op.drop_table('turn')
    op.drop_table('sell_offer')
    op.drop_table('overloaded_currency')
    op.drop_table('hoarded_currency')
    op.drop_table('debtor_info')
    with op.batch_alter_table('currency_info', schema=None) as batch_op:
        batch_op.drop_index('idx_currency_info_confirmed_debtor_id', postgresql_where=sa.text('is_confirmed'))

    op.drop_table('currency_info')
    op.drop_table('creditor_taking')
    op.drop_table('creditor_giving')
    op.drop_table('confirmed_debtor')
    op.drop_table('collector_sending')
    op.drop_table('collector_receiving')
    op.drop_table('collector_dispatching')
    op.drop_table('collector_collecting')
    with op.batch_alter_table('collector_account', schema=None) as batch_op:
        batch_op.drop_index('idx_collector_account_creation_request', postgresql_where=sa.text('status = 0'))

    op.drop_table('collector_account')
    op.drop_table('buy_offer')
    # ### end Alembic commands ###

