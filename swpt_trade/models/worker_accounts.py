from __future__ import annotations
from datetime import timedelta
from sqlalchemy.sql.expression import null, or_, and_
from swpt_trade.extensions import db
from .common import get_now_utc, TS0, MIN_INT32, ChooseRowsMixin


class NeededWorkerAccount(db.Model, ChooseRowsMixin):
    creditor_id = db.Column(db.BigInteger, primary_key=True)
    debtor_id = db.Column(db.BigInteger, primary_key=True)
    configured_at = db.Column(
        db.TIMESTAMP(timezone=True), nullable=False, default=get_now_utc
    )
    collection_disabled_since = db.Column(db.TIMESTAMP(timezone=True))
    blocked_amount = db.Column(db.BigInteger, nullable=False, default=0)
    blocked_amount_ts = db.Column(
        db.TIMESTAMP(timezone=True), nullable=False, default=TS0
    )
    __table_args__ = (
        db.CheckConstraint(blocked_amount >= 0),
        {
            "comment": (
                'Represents the fact that a "worker" server has requested'
                ' the configuration (aka creation) of a Swaptacular account,'
                ' which will be used to collect and dispatch transfers.'
            ),
        },
    )


class WorkerAccount(db.Model, ChooseRowsMixin):
    CONFIG_SCHEDULED_FOR_DELETION_FLAG = 1 << 0

    creditor_id = db.Column(db.BigInteger, primary_key=True)
    debtor_id = db.Column(db.BigInteger, primary_key=True)
    creation_date = db.Column(db.DATE, nullable=False)
    last_change_ts = db.Column(db.TIMESTAMP(timezone=True), nullable=False)
    last_change_seqnum = db.Column(db.Integer, nullable=False)
    principal = db.Column(db.BigInteger, nullable=False)
    interest = db.Column(db.FLOAT, nullable=False)
    interest_rate = db.Column(db.REAL, nullable=False)
    last_interest_rate_change_ts = db.Column(
        db.TIMESTAMP(timezone=True), nullable=False
    )
    config_flags = db.Column(db.Integer, nullable=False)
    account_id = db.Column(db.String, nullable=False)
    debtor_info_iri = db.Column(db.String)
    last_transfer_number = db.Column(db.BigInteger, nullable=False)
    last_transfer_committed_at = db.Column(
        db.TIMESTAMP(timezone=True), nullable=False
    )
    demurrage_rate = db.Column(db.FLOAT, nullable=False)
    commit_period = db.Column(db.Integer, nullable=False)
    transfer_note_max_bytes = db.Column(db.Integer, nullable=False)
    last_heartbeat_ts = db.Column(
        db.TIMESTAMP(timezone=True), nullable=False, default=get_now_utc
    )
    surplus_amount = db.Column(
        db.BigInteger,
        nullable=False,
        default=0,
        comment="The calculated surplus on this account. The surplus can"
                " be spent on behalf of the owner of the creditors agent"
                " node.",
    )
    surplus_ts = db.Column(
        db.TIMESTAMP(timezone=True),
        nullable=False,
        default=TS0,
        comment="The moment when the surplus was observed. This is needed"
                " so that, for the current moment, we can calculate the"
                " maximum possible demurrage that surplus may have suffered.",
    )
    surplus_spent_amount = db.Column(
        db.BigInteger,
        nullable=False,
        default=0,
        comment="The surplus amount which already has been spent on behalf"
                " of the owner of the creditors agent node.",
    )
    surplus_last_transfer_number = db.Column(
        db.BigInteger,
        nullable=False,
        default=0,
        comment="This number must be incremented each time when `surplus_ts`"
                " change, or a trade has been made on behalf of the owner of"
                " the creditors agent node. This is necessary in order to"
                " avoid double-spending and double-buying.",
    )
    last_surplus_moving_turn_id = db.Column(
        db.Integer,
        nullable=False,
        default=MIN_INT32,
    )
    __table_args__ = (
        db.CheckConstraint(interest_rate >= -100.0),
        db.CheckConstraint(transfer_note_max_bytes >= 0),
        db.CheckConstraint(last_transfer_number >= 0),
        db.CheckConstraint(
            and_(demurrage_rate >= -100.0, demurrage_rate <= 0.0)
        ),
        db.CheckConstraint(commit_period >= 0),
        db.CheckConstraint(surplus_amount >= 0),
        db.CheckConstraint(surplus_last_transfer_number >= 0),
        db.CheckConstraint(surplus_spent_amount >= 0),
        {
            "comment": (
                'Represents an existing Swaptacular account, managed by a '
                ' "worker" server. The account is used to collect and dispatch'
                ' transfers.'
            ),
        },
    )


WORST_NODE_CLOCKS_MISMATCH = timedelta(hours=36)

KNOWN_SURPLUS_AMOUNT_PREDICATE = and_(
    NeededWorkerAccount.blocked_amount_ts
    >= NeededWorkerAccount.collection_disabled_since,

    # NOTE: Here we give a huge (36h) slack, because the timestamps
    # that we compare are generated by 2 different nodes:
    # `blocked_amount_ts` is generated by us, but `last_heartbeat_ts`
    # is generated by the accounting authority node.
    WorkerAccount.last_heartbeat_ts
    > NeededWorkerAccount.blocked_amount_ts + WORST_NODE_CLOCKS_MISMATCH,
)
WORKER_ACCOUNT_TABLES_JOIN_PREDICATE = and_(
    NeededWorkerAccount.creditor_id == WorkerAccount.creditor_id,
    NeededWorkerAccount.debtor_id == WorkerAccount.debtor_id,
)


class InterestRateChange(db.Model, ChooseRowsMixin):
    # NOTE: The `interest_rate` column is not be part of the primary
    # key, but it probably is a good idea to include it in the primary
    # key index to allow index-only scans. Because SQLAlchemy does not
    # support this yet (2024-01-19), the migration file should be
    # edited so as not to create a "normal" index, but create a
    # "covering" index instead.

    # TODO: Consider solving the following hypothetical problem:
    #
    # When the interest rate has been changed twice (or more) in a
    # relatively short period of time and the `AccountUpdate` SMP
    # message for the second change has been received, but the
    # `AccountUpdate` message for the first change has not been
    # received yet, the data in this table will indicate the wrong
    # overall interest rate, which may lead to a wrong calculation for
    # the amount that needs to be transferred.
    #
    # *Important note*: The Swaptacular Messaging Protocol
    # specification states that the accounting authority nodes MUST
    # NOT allow this to happen.
    #
    # One possible way to fix this hypothetical problem (if it happens
    # to be a problem in practice, which is unlikely) would be to
    # detect when one or more `AccountUpdate` messages have been
    # missing, by keeping track of the numbers in the
    # `last_change_seqnum` field of all received `AccountUpdate`
    # messages. Then, in case is conceivable that some changes in the
    # interest rate may have gone unnoticed, the calculation of the
    # amounts that needs to be transferred would be postponed until
    # all missing `AccountUpdate` messages have been received.

    creditor_id = db.Column(db.BigInteger, primary_key=True)
    debtor_id = db.Column(db.BigInteger, primary_key=True)
    change_ts = db.Column(db.TIMESTAMP(timezone=True), primary_key=True)
    interest_rate = db.Column(db.REAL, nullable=False)
    __table_args__ = (
        db.CheckConstraint(interest_rate >= -100.0),
        {
            "comment": (
                "Indicates a change in the interest rate on a given collector"
                " account. The history of recent interest rate changes is"
                " needed in order to correctly determine the due interest"
                " on traded amounts."
            ),
        },
    )


class CollectorStatusChange(db.Model, ChooseRowsMixin):
    collector_id = db.Column(db.BigInteger, primary_key=True)
    change_id = db.Column(db.BigInteger, primary_key=True, autoincrement=True)
    debtor_id = db.Column(db.BigInteger, nullable=False)
    from_status = db.Column(db.SmallInteger, nullable=False)
    to_status = db.Column(db.SmallInteger, nullable=False)
    account_id = db.Column(db.String)
    __table_args__ = (
        db.CheckConstraint(or_(
            # Sent "ConfigureAccount" message:
            and_(from_status == 0, to_status == 1, account_id == null()),
            # Received account ID:
            and_(from_status == 1, to_status == 2, account_id != null()),
            # Calculated surplus amount:
            and_(from_status == 3, to_status == 2, account_id == null()),
            # Detected broken worker account:
            and_(from_status == 3, to_status == 1, account_id == null()),
        )),
        {
            "comment": (
                'Represents a pending change in the status of a collector'
                ' account on the solver server.'
            ),
        },
    )


class NeededCollectorAccount(db.Model, ChooseRowsMixin):
    debtor_id = db.Column(db.BigInteger, primary_key=True)
    collector_id = db.Column(db.BigInteger, primary_key=True)
    __table_args__ = (
        {
            "comment": (
                'Represents the pending creation of a collector account'
                ' on the solver server.'
            ),
        },
    )


class RecentlyNeededCollector(db.Model, ChooseRowsMixin):
    debtor_id = db.Column(db.BigInteger, primary_key=True, autoincrement=False)
    needed_at = db.Column(
        db.TIMESTAMP(timezone=True), nullable=False, default=get_now_utc
    )
    __table_args__ = (
        db.CheckConstraint(debtor_id != 0),
        {
            "comment": (
                'Indicates that the creation of a collector account for the'
                ' currency with the given debtor ID has been recently'
                ' requested. This information is used to prevent "worker"'
                ' servers from making repetitive queries to the central'
                " database."
            ),
        },
    )


class UsableCollector(db.Model, ChooseRowsMixin):
    debtor_id = db.Column(db.BigInteger, primary_key=True)
    collector_id = db.Column(db.BigInteger, primary_key=True)
    account_id = db.Column(db.String, nullable=False)
    disabled_at = db.Column(db.TIMESTAMP(timezone=True))
    __table_args__ = (
        db.Index(
            "idx_usable_collector_collector_id",
            collector_id,
            debtor_id,
            unique=True,
        ),
        db.CheckConstraint(account_id != ""),
        {
            "comment": (
                'Represents an existing Swaptacular account which can be'
                ' used to collect and dispatch transfers. Each "Worker"'
                ' servers will maintain its own copy of this table (that is:'
                ' no rows-sharding) by periodically copying the relevant'
                ' records from the solver\'s "collector_account" table.'
                ' "Worker" servers will use this local copy so as to avoid'
                ' querying the central database too often.'
            ),
        },
    )


class WorkerHoardedCurrency(db.Model):
    debtor_id = db.Column(db.BigInteger, primary_key=True, autoincrement=False)
    __table_args__ = (
        {
            "comment": (
                'Represents the fact that the owner of the creditors agent'
                ' node wants to buy (hoard) the given currency.'
            ),
        },
    )
